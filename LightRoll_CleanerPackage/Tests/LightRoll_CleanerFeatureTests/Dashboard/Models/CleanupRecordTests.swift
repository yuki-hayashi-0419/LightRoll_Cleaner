//
//  CleanupRecordTests.swift
//  LightRoll_CleanerFeatureTests
//
//  CleanupRecordモデルの包括的な単体テスト
//  Created by AI Assistant
//

import Foundation
import Testing

@testable import LightRoll_CleanerFeature

// MARK: - CleanupRecord Initialization Tests

@Suite("CleanupRecord 初期化テスト")
struct CleanupRecordInitializationTests {

    @Test("全プロパティを指定して初期化できる")
    func testFullInitialization() {
        let id = UUID()
        let date = Date()

        let record = CleanupRecord(
            id: id,
            date: date,
            deletedCount: 50,
            freedSpace: 1_000_000_000, // 1GB
            groupType: .similar,
            operationType: .manual
        )

        #expect(record.id == id)
        #expect(record.date == date)
        #expect(record.deletedCount == 50)
        #expect(record.freedSpace == 1_000_000_000)
        #expect(record.groupType == .similar)
        #expect(record.operationType == .manual)
    }

    @Test("簡易イニシャライザで必須項目のみ指定できる")
    func testSimpleInitialization() {
        let record = CleanupRecord(deletedCount: 10, freedSpace: 500_000)

        #expect(record.deletedCount == 10)
        #expect(record.freedSpace == 500_000)
        #expect(record.groupType == nil)
        #expect(record.operationType == .manual)
    }

    @Test("負の削除数は0にクランプされる")
    func testNegativeDeletedCountClamping() {
        let record = CleanupRecord(deletedCount: -10, freedSpace: 1000)
        #expect(record.deletedCount == 0)
    }

    @Test("負の解放容量は0にクランプされる")
    func testNegativeFreedSpaceClamping() {
        let record = CleanupRecord(deletedCount: 10, freedSpace: -1000)
        #expect(record.freedSpace == 0)
    }

    @Test("デフォルトのIDが自動生成される")
    func testAutoGeneratedId() {
        let record1 = CleanupRecord(deletedCount: 10, freedSpace: 1000)
        let record2 = CleanupRecord(deletedCount: 10, freedSpace: 1000)

        #expect(record1.id != record2.id)
    }

    @Test("デフォルトの日付が現在時刻に設定される")
    func testDefaultDate() {
        let before = Date()
        let record = CleanupRecord(deletedCount: 10, freedSpace: 1000)
        let after = Date()

        #expect(record.date >= before)
        #expect(record.date <= after)
    }
}

// MARK: - CleanupRecord OperationType Tests

@Suite("CleanupRecord.OperationType テスト")
struct CleanupRecordOperationTypeTests {

    @Test("全てのOperationTypeがdisplayNameを持つ")
    func testAllOperationTypesHaveDisplayName() {
        for type in CleanupRecord.OperationType.allCases {
            #expect(!type.displayName.isEmpty)
        }
    }

    @Test("全てのOperationTypeがiconを持つ")
    func testAllOperationTypesHaveIcon() {
        for type in CleanupRecord.OperationType.allCases {
            #expect(!type.icon.isEmpty)
        }
    }

    @Test("OperationType.iconがSF Symbol名を返す")
    func testOperationTypeIcons() {
        #expect(CleanupRecord.OperationType.manual.icon == "hand.tap")
        #expect(CleanupRecord.OperationType.quickClean.icon == "sparkles")
        #expect(CleanupRecord.OperationType.bulkDelete.icon == "trash.fill")
        #expect(CleanupRecord.OperationType.automatic.icon == "clock.arrow.circlepath")
    }

    @Test("OperationTypeがCodable準拠している")
    func testOperationTypeCodable() throws {
        for type in CleanupRecord.OperationType.allCases {
            let encoded = try JSONEncoder().encode(type)
            let decoded = try JSONDecoder().decode(CleanupRecord.OperationType.self, from: encoded)
            #expect(decoded == type)
        }
    }
}

// MARK: - CleanupRecord Computed Properties Tests

@Suite("CleanupRecord 算出プロパティテスト")
struct CleanupRecordComputedPropertiesTests {

    @Test("formattedFreedSpaceが人間可読形式を返す")
    func testFormattedFreedSpace() {
        let record = CleanupRecord(
            deletedCount: 100,
            freedSpace: 1_500_000_000 // 1.5GB
        )
        #expect(!record.formattedFreedSpace.isEmpty)
        // ByteCountFormatterの結果を確認
    }

    @Test("formattedDateが短い日付形式を返す")
    func testFormattedDate() {
        let calendar = Calendar.current
        let components = DateComponents(year: 2025, month: 11, day: 25)
        let date = calendar.date(from: components)!

        let record = CleanupRecord(
            id: UUID(),
            date: date,
            deletedCount: 10,
            freedSpace: 1000
        )

        #expect(record.formattedDate.contains("11"))
        #expect(record.formattedDate.contains("25"))
    }

    @Test("formattedDateTimeが日時形式を返す")
    func testFormattedDateTime() {
        let record = CleanupRecord(deletedCount: 10, freedSpace: 1000)
        #expect(!record.formattedDateTime.isEmpty)
    }

    @Test("formattedRelativeDateが相対形式を返す")
    func testFormattedRelativeDate() {
        let record = CleanupRecord(deletedCount: 10, freedSpace: 1000)
        #expect(!record.formattedRelativeDate.isEmpty)
    }

    @Test("summaryが正しい形式を返す")
    func testSummary() {
        let record = CleanupRecord(deletedCount: 156, freedSpace: 1_200_000_000)
        let summary = record.summary
        #expect(summary.contains("156"))
    }

    @Test("detailedSummaryが日付付きサマリーを返す")
    func testDetailedSummary() {
        let record = CleanupRecord(deletedCount: 100, freedSpace: 1000)
        let detailed = record.detailedSummary
        #expect(detailed.contains(record.formattedDate))
    }

    @Test("groupTypeDisplayNameがnilの場合に混合を返す")
    func testGroupTypeDisplayNameNil() {
        let record = CleanupRecord(deletedCount: 10, freedSpace: 1000, groupType: nil)
        #expect(!record.groupTypeDisplayName.isEmpty)
    }

    @Test("groupTypeDisplayNameがタイプ名を返す")
    func testGroupTypeDisplayNameWithType() {
        let record = CleanupRecord(
            id: UUID(),
            date: Date(),
            deletedCount: 10,
            freedSpace: 1000,
            groupType: .similar
        )
        #expect(record.groupTypeDisplayName == GroupType.similar.displayName)
    }

    @Test("isValidが正しく判定される")
    func testIsValid() {
        let validRecord = CleanupRecord(deletedCount: 10, freedSpace: 1000)
        #expect(validRecord.isValid == true)

        let invalidCount = CleanupRecord(deletedCount: 0, freedSpace: 1000)
        #expect(invalidCount.isValid == false)

        let invalidSpace = CleanupRecord(deletedCount: 10, freedSpace: 0)
        #expect(invalidSpace.isValid == false)
    }
}

// MARK: - CleanupRecord Codable Tests

@Suite("CleanupRecord Codable テスト")
struct CleanupRecordCodableTests {

    @Test("CleanupRecordがエンコード・デコードできる")
    func testCodable() throws {
        let original = CleanupRecord(
            id: UUID(),
            date: Date(),
            deletedCount: 50,
            freedSpace: 1_000_000,
            groupType: .screenshot,
            operationType: .quickClean
        )

        let encoded = try JSONEncoder().encode(original)
        let decoded = try JSONDecoder().decode(CleanupRecord.self, from: encoded)

        #expect(decoded.id == original.id)
        #expect(decoded.deletedCount == original.deletedCount)
        #expect(decoded.freedSpace == original.freedSpace)
        #expect(decoded.groupType == original.groupType)
        #expect(decoded.operationType == original.operationType)
    }

    @Test("groupTypeがnilの場合でもエンコード・デコードできる")
    func testCodableWithNilGroupType() throws {
        let original = CleanupRecord(deletedCount: 10, freedSpace: 1000)

        let encoded = try JSONEncoder().encode(original)
        let decoded = try JSONDecoder().decode(CleanupRecord.self, from: encoded)

        #expect(decoded.groupType == nil)
    }
}

// MARK: - CleanupRecord Comparable Tests

@Suite("CleanupRecord Comparable テスト")
struct CleanupRecordComparableTests {

    @Test("日付で降順にソートされる")
    func testComparable() {
        let calendar = Calendar.current

        let oldDate = calendar.date(byAdding: .day, value: -7, to: Date())!
        let recentDate = Date()

        let oldRecord = CleanupRecord(
            id: UUID(),
            date: oldDate,
            deletedCount: 10,
            freedSpace: 1000
        )
        let recentRecord = CleanupRecord(
            id: UUID(),
            date: recentDate,
            deletedCount: 10,
            freedSpace: 1000
        )

        // < 演算子は新しい日付が「小さい」と判定（降順ソート用）
        #expect(recentRecord < oldRecord)
    }
}

// MARK: - CleanupRecord Protocol Conformance Tests

@Suite("CleanupRecord プロトコル準拠テスト")
struct CleanupRecordProtocolConformanceTests {

    @Test("CleanupRecordがIdentifiable準拠している")
    func testIdentifiable() {
        let record = CleanupRecord(deletedCount: 10, freedSpace: 1000)
        let _ = record.id // Identifiable要件
    }

    @Test("CleanupRecordがHashable準拠している")
    func testHashable() {
        let record1 = CleanupRecord(deletedCount: 10, freedSpace: 1000)
        let record2 = CleanupRecord(deletedCount: 10, freedSpace: 1000)

        // 異なるIDなので異なるハッシュ値
        var set = Set<CleanupRecord>()
        set.insert(record1)
        set.insert(record2)
        #expect(set.count == 2)
    }

    @Test("CleanupRecordがSendable準拠している")
    func testSendable() async {
        let record = CleanupRecord(deletedCount: 10, freedSpace: 1000)

        let result = await Task.detached {
            record.deletedCount
        }.value

        #expect(result == 10)
    }

    @Test("CleanupRecordのdescriptionが期待通りの形式")
    func testCustomStringConvertible() {
        let record = CleanupRecord(
            deletedCount: 50,
            freedSpace: 1_000_000
        )

        let description = record.description
        #expect(description.contains("CleanupRecord"))
        #expect(description.contains("deleted: 50"))
    }
}

// MARK: - CleanupRecordStatistics Tests

@Suite("CleanupRecordStatistics テスト")
struct CleanupRecordStatisticsTests {

    @Test("空の統計が正しい初期値を持つ")
    func testEmptyStatistics() {
        let empty = CleanupRecordStatistics.empty

        #expect(empty.totalRecords == 0)
        #expect(empty.totalDeletedCount == 0)
        #expect(empty.totalFreedSpace == 0)
        #expect(empty.countByOperationType.isEmpty)
        #expect(empty.deletedCountByGroupType.isEmpty)
        #expect(empty.latestCleanupDate == nil)
        #expect(empty.oldestCleanupDate == nil)
    }

    @Test("formattedTotalFreedSpaceが文字列を返す")
    func testFormattedTotalFreedSpace() {
        let stats = CleanupRecordStatistics(
            totalRecords: 10,
            totalDeletedCount: 500,
            totalFreedSpace: 5_000_000_000,
            countByOperationType: [:],
            deletedCountByGroupType: [:],
            latestCleanupDate: Date(),
            oldestCleanupDate: Date()
        )

        #expect(!stats.formattedTotalFreedSpace.isEmpty)
    }

    @Test("averageDeletedCountが正しく計算される")
    func testAverageDeletedCount() {
        let stats = CleanupRecordStatistics(
            totalRecords: 10,
            totalDeletedCount: 500,
            totalFreedSpace: 1000,
            countByOperationType: [:],
            deletedCountByGroupType: [:],
            latestCleanupDate: nil,
            oldestCleanupDate: nil
        )

        #expect(stats.averageDeletedCount == 50.0)
    }

    @Test("averageDeletedCountがtotalRecords=0で0を返す")
    func testAverageDeletedCountZeroRecords() {
        let stats = CleanupRecordStatistics.empty
        #expect(stats.averageDeletedCount == 0)
    }

    @Test("averageFreedSpaceが正しく計算される")
    func testAverageFreedSpace() {
        let stats = CleanupRecordStatistics(
            totalRecords: 10,
            totalDeletedCount: 100,
            totalFreedSpace: 10_000_000_000, // 10GB
            countByOperationType: [:],
            deletedCountByGroupType: [:],
            latestCleanupDate: nil,
            oldestCleanupDate: nil
        )

        #expect(stats.averageFreedSpace == 1_000_000_000) // 1GB
    }

    @Test("formattedAverageFreedSpaceが文字列を返す")
    func testFormattedAverageFreedSpace() {
        let stats = CleanupRecordStatistics(
            totalRecords: 5,
            totalDeletedCount: 50,
            totalFreedSpace: 5_000_000_000,
            countByOperationType: [:],
            deletedCountByGroupType: [:],
            latestCleanupDate: nil,
            oldestCleanupDate: nil
        )

        #expect(!stats.formattedAverageFreedSpace.isEmpty)
    }
}

// MARK: - Array+CleanupRecord Extension Tests

@Suite("Array+CleanupRecord 拡張テスト")
struct ArrayCleanupRecordExtensionTests {

    // テスト用のサンプルレコード配列を作成
    private func createSampleRecords() -> [CleanupRecord] {
        let calendar = Calendar.current
        let now = Date()

        return [
            CleanupRecord(
                id: UUID(),
                date: now,
                deletedCount: 100,
                freedSpace: 1_000_000_000,
                groupType: .similar,
                operationType: .manual
            ),
            CleanupRecord(
                id: UUID(),
                date: calendar.date(byAdding: .day, value: -1, to: now)!,
                deletedCount: 50,
                freedSpace: 500_000_000,
                groupType: .screenshot,
                operationType: .quickClean
            ),
            CleanupRecord(
                id: UUID(),
                date: calendar.date(byAdding: .day, value: -7, to: now)!,
                deletedCount: 200,
                freedSpace: 2_000_000_000,
                groupType: .similar,
                operationType: .bulkDelete
            ),
            CleanupRecord(
                id: UUID(),
                date: calendar.date(byAdding: .day, value: -30, to: now)!,
                deletedCount: 30,
                freedSpace: 300_000_000,
                groupType: nil,
                operationType: .automatic
            )
        ]
    }

    // MARK: - Filtering Tests

    @Test("filterByDateRangeが期間内のレコードを返す")
    func testFilterByDateRange() {
        let records = createSampleRecords()
        let calendar = Calendar.current
        let now = Date()
        let fiveDaysAgo = calendar.date(byAdding: .day, value: -5, to: now)!

        let filtered = records.filterByDateRange(from: fiveDaysAgo, to: now)
        #expect(filtered.count == 2) // 今日と1日前のレコード
    }

    @Test("filterLastDaysが過去N日のレコードを返す")
    func testFilterLastDays() {
        let records = createSampleRecords()
        let filtered = records.filterLastDays(10)

        #expect(filtered.count == 3) // 30日前を除く3件
    }

    @Test("filterByGroupTypeが指定タイプのレコードを返す")
    func testFilterByGroupType() {
        let records = createSampleRecords()
        let filtered = records.filterByGroupType(.similar)

        #expect(filtered.count == 2)
        #expect(filtered.allSatisfy { $0.groupType == .similar })
    }

    @Test("filterByOperationTypeが指定タイプのレコードを返す")
    func testFilterByOperationType() {
        let records = createSampleRecords()
        let filtered = records.filterByOperationType(.quickClean)

        #expect(filtered.count == 1)
        #expect(filtered.first?.operationType == .quickClean)
    }

    @Test("validRecordsが有効なレコードのみを返す")
    func testValidRecords() {
        let records = [
            CleanupRecord(deletedCount: 10, freedSpace: 1000),
            CleanupRecord(deletedCount: 0, freedSpace: 1000),
            CleanupRecord(deletedCount: 10, freedSpace: 0)
        ]

        let valid = records.validRecords
        #expect(valid.count == 1)
    }

    // MARK: - Sorting Tests

    @Test("sortedByDateDescendingが新しい順にソートする")
    func testSortedByDateDescending() {
        let records = createSampleRecords()
        let sorted = records.sortedByDateDescending

        for i in 0..<(sorted.count - 1) {
            #expect(sorted[i].date >= sorted[i + 1].date)
        }
    }

    @Test("sortedByDateAscendingが古い順にソートする")
    func testSortedByDateAscending() {
        let records = createSampleRecords()
        let sorted = records.sortedByDateAscending

        for i in 0..<(sorted.count - 1) {
            #expect(sorted[i].date <= sorted[i + 1].date)
        }
    }

    @Test("sortedByFreedSpaceが解放容量順にソートする")
    func testSortedByFreedSpace() {
        let records = createSampleRecords()
        let sorted = records.sortedByFreedSpace

        for i in 0..<(sorted.count - 1) {
            #expect(sorted[i].freedSpace >= sorted[i + 1].freedSpace)
        }
    }

    @Test("sortedByDeletedCountが削除枚数順にソートする")
    func testSortedByDeletedCount() {
        let records = createSampleRecords()
        let sorted = records.sortedByDeletedCount

        for i in 0..<(sorted.count - 1) {
            #expect(sorted[i].deletedCount >= sorted[i + 1].deletedCount)
        }
    }

    // MARK: - Statistics Tests

    @Test("statisticsが正しく計算される")
    func testStatistics() {
        let records = createSampleRecords()
        let stats = records.statistics

        #expect(stats.totalRecords == 4)
        #expect(stats.totalDeletedCount == 380) // 100 + 50 + 200 + 30
        #expect(stats.totalFreedSpace == 3_800_000_000)
        #expect(stats.countByOperationType[.manual] == 1)
        #expect(stats.countByOperationType[.quickClean] == 1)
        #expect(stats.countByOperationType[.bulkDelete] == 1)
        #expect(stats.countByOperationType[.automatic] == 1)
        #expect(stats.deletedCountByGroupType[.similar] == 300) // 100 + 200
        #expect(stats.deletedCountByGroupType[.screenshot] == 50)
    }

    @Test("totalDeletedCountが正しく計算される")
    func testTotalDeletedCount() {
        let records = createSampleRecords()
        #expect(records.totalDeletedCount == 380)
    }

    @Test("totalFreedSpaceが正しく計算される")
    func testTotalFreedSpace() {
        let records = createSampleRecords()
        #expect(records.totalFreedSpace == 3_800_000_000)
    }

    @Test("formattedTotalFreedSpaceが文字列を返す")
    func testFormattedTotalFreedSpace() {
        let records = createSampleRecords()
        #expect(!records.formattedTotalFreedSpace.isEmpty)
    }

    @Test("latestCleanupDateが最新の日付を返す")
    func testLatestCleanupDate() {
        let records = createSampleRecords()
        let latest = records.latestCleanupDate

        #expect(latest != nil)
        // 最新のレコードの日付であることを確認
        let sortedRecords = records.sortedByDateDescending
        #expect(latest == sortedRecords.first?.date)
    }

    // MARK: - Grouping Tests

    @Test("groupedByDayが日ごとにグルーピングする")
    func testGroupedByDay() {
        let records = createSampleRecords()
        let grouped = records.groupedByDay

        // 4つの異なる日付
        #expect(grouped.keys.count == 4)
    }

    @Test("groupedByMonthが月ごとにグルーピングする")
    func testGroupedByMonth() {
        let records = createSampleRecords()
        let grouped = records.groupedByMonth

        // 全て同じ月（テスト実行月）か1ヶ月違いの可能性
        #expect(!grouped.isEmpty)
    }

    @Test("groupedByOperationTypeが操作タイプごとにグルーピングする")
    func testGroupedByOperationType() {
        let records = createSampleRecords()
        let grouped = records.groupedByOperationType

        #expect(grouped[.manual]?.count == 1)
        #expect(grouped[.quickClean]?.count == 1)
        #expect(grouped[.bulkDelete]?.count == 1)
        #expect(grouped[.automatic]?.count == 1)
    }
}

// MARK: - Edge Case Tests

@Suite("CleanupRecord エッジケーステスト")
struct CleanupRecordEdgeCaseTests {

    @Test("最大値のInt64を処理できる")
    func testMaxInt64FreedSpace() {
        let record = CleanupRecord(
            deletedCount: 1,
            freedSpace: Int64.max
        )
        #expect(record.freedSpace == Int64.max)
    }

    @Test("最大値のIntを処理できる")
    func testMaxIntDeletedCount() {
        let record = CleanupRecord(
            deletedCount: Int.max,
            freedSpace: 1000
        )
        #expect(record.deletedCount == Int.max)
    }

    @Test("空の配列でstatisticsがemptyを返す")
    func testEmptyArrayStatistics() {
        let records: [CleanupRecord] = []
        let stats = records.statistics

        #expect(stats.totalRecords == 0)
        #expect(stats.totalDeletedCount == 0)
        #expect(stats.totalFreedSpace == 0)
    }

    @Test("空の配列でlatestCleanupDateがnilを返す")
    func testEmptyArrayLatestDate() {
        let records: [CleanupRecord] = []
        #expect(records.latestCleanupDate == nil)
    }
}
