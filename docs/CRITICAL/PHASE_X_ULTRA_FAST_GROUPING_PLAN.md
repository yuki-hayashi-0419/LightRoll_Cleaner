# Phase X: 超高速グルーピング最適化計画

## 概要

| 項目 | 値 |
|------|-----|
| 現状 | 115GB（100,000枚）で60-80分（Phase 1実装後も改善効果不明確） |
| 目標 | 1TBでも**数分**で完了（90%以上の改善） |
| 対象 | LightRoll Cleaner アプリ - グルーピング処理 |
| 作成日 | 2026-01-06 |
| 作成者 | @spec-architect |
| バージョン | 1.0 |

---

## 1. Phase 1が効果がなかった理由

### 1.1 Phase 1の実装内容（A1-A4）

| タスク | 内容 | 期待改善率 |
|--------|------|-----------|
| A1 | groupDuplicates並列化 | 15% |
| A2 | groupLargeVideos並列化 | 5% |
| A3 | getFileSizesバッチ制限 | 10% |
| A4 | estimatedFileSize優先使用 | 20% |
| **合計** | **50%改善（60-80分→30-40分）** | **達成見込み** |

### 1.2 効果が限定的だった根本原因

#### 原因1: 最適化のターゲットがボトルネックの本質ではなかった

```
Phase 1の最適化対象:
┌─────────────────────────────────────────────────────────────────┐
│  getFileSizes()の並列化・バッチ制限                              │
│  → ファイルサイズ取得の効率化                                    │
└─────────────────────────────────────────────────────────────────┘

しかし、真のボトルネック:
┌─────────────────────────────────────────────────────────────────┐
│  類似度計算（O(n^2)）の計算量爆発                                │
│  → 100,000枚 × 100,000枚 = 100億回の比較                        │
└─────────────────────────────────────────────────────────────────┘
```

#### 原因2: I/O最適化の限界

- ファイルサイズ取得の並列化は「I/Oバウンド」問題の一部を解決
- しかし、グルーピング処理の大部分は「CPUバウンド」
- **時間分布の実態**:
  - ファイルサイズ取得: 約10-15%
  - 類似度計算: 約60-70%
  - ハッシュ計算・グループ構築: 約15-20%

#### 原因3: アルゴリズムの計算量が根本的に問題

```
現在のアルゴリズム計算量:
- 類似度計算: O(n^2) - n=100,000で100億回
- ファイルサイズ取得: O(n) - n=100,000で10万回

Phase 1は O(n) の部分を最適化
→ O(n^2) の部分が支配的なため、全体への影響は限定的
```

### 1.3 Phase 1の成果と限界

| 項目 | 成果 | 限界 |
|------|------|------|
| メモリ使用量 | ピーク70%削減 | 処理時間には直接影響せず |
| I/O競合 | 解消 | CPUバウンドが残存 |
| キャンセル対応 | 改善 | 本質的な高速化ではない |
| **処理時間** | **微減（5-10%程度）** | **目標50%未達** |

---

## 2. 真のボトルネック分析

### 2.1 プロファイリング結果（推定）

```
処理時間の内訳（100,000枚、60分として）:

┌─────────────────────────────────────────────────────────────┐
│ 類似度計算（コサイン類似度）                    │ 36分 (60%) │
│ ├─ FeaturePrint比較                          │ 30分       │
│ └─ 結果マッピング                            │ 6分        │
├─────────────────────────────────────────────────────────────┤
│ ハッシュ計算（LSHHasher）                     │ 9分 (15%)  │
│ ├─ VNFeaturePrint → LSHHash変換              │ 6分        │
│ └─ ハッシュテーブル構築                       │ 3分        │
├─────────────────────────────────────────────────────────────┤
│ ファイルサイズ取得                           │ 9分 (15%)  │
│ ├─ PHAssetResource I/O                      │ 7分        │
│ └─ キャッシュ操作                           │ 2分        │
├─────────────────────────────────────────────────────────────┤
│ グループ構築（Union-Find等）                 │ 6分 (10%)  │
│ ├─ Union-Find操作                           │ 4分        │
│ └─ 結果構造化                               │ 2分        │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 計算量の問題

#### 類似度計算の計算量爆発

```
n枚の写真に対する類似度計算:
- 全ペア比較: n * (n-1) / 2 回
- n = 100,000 の場合: 約50億回
- 1回の比較が 1μs でも: 50億 × 1μs = 5,000秒 ≈ 83分

→ アルゴリズム的改善なしには解決不可能
```

#### LSHによる削減効果の限界

```
現在のLSH実装:
- バンド数: 20
- 行数: 5
- 候補ペア削減率: 約90%

それでも:
- 候補ペア数: 50億 × 10% = 5億ペア
- 実際の類似度計算: 5億回
- 時間: 5億 × 1μs = 500秒 ≈ 8分

→ LSH後の類似度計算自体が依然として重い
```

### 2.3 メモリアクセスパターンの問題

```
現在のメモリアクセスパターン:
┌─────────────────────────────────────────────────────────────┐
│ FeaturePrint配列                                            │
│ [FP_0][FP_1][FP_2]...[FP_99999]                              │
│                                                             │
│ 比較時のアクセス:                                            │
│ compare(FP_0, FP_1) → キャッシュヒット（連続）              │
│ compare(FP_0, FP_50000) → キャッシュミス（ランダム）        │
└─────────────────────────────────────────────────────────────┘

→ LSH候補ペアはランダムアクセスパターンになりがち
→ CPU L3キャッシュミスが頻発
```

---

## 3. 5つのアーキテクチャ案

### パターンA: LSHパラメータ最適化

**概要**: 既存LSHのパラメータ調整でFalse Positive削減

| 項目 | 内容 |
|------|------|
| 変更点 | バンド数・行数の最適化、ハッシュ関数の改善 |
| 期待改善 | 20-30% |
| 工数 | 16h（2日） |
| リスク | False Negativeの増加 |

```
変更案:
- バンド数: 20 → 30（候補ペア削減）
- 行数: 5 → 4（バランス調整）
- 期待候補ペア削減率: 90% → 95%
```

**評価**: 改善効果は限定的。根本的解決にはならない。

---

### パターンB: 時間ベース事前グルーピング強化

**概要**: 撮影時間による事前フィルタリングを強化

| 項目 | 内容 |
|------|------|
| 変更点 | 時間窓を狭める、日付単位のグルーピング |
| 期待改善 | 30-40% |
| 工数 | 24h（3日） |
| リスク | 異なる日の類似写真を見逃す |

```
変更案:
- 現在の時間窓: 数時間
- 新時間窓: 10分（バースト撮影対応）
- 日付単位で独立処理 → 並列化可能

データフロー:
[全写真] → [日付別分割] → [各日付内でLSH] → [結果統合]
            ↓ 並列処理
         Day1 → LSH → Groups
         Day2 → LSH → Groups
         Day3 → LSH → Groups
```

**評価**: 効果的だが、日をまたぐ類似写真を見逃すリスク。

---

### パターンC: 類似度計算のSIMD最適化

**概要**: コサイン類似度計算をSIMD命令で高速化

| 項目 | 内容 |
|------|------|
| 変更点 | SimilarityCalculatorのSIMD実装 |
| 期待改善 | 40-50%（計算部分のみ） |
| 工数 | 32h（4日） |
| リスク | プラットフォーム依存性 |

```swift
// 現在の実装（推定）
func cosineSimilarity(_ a: [Float], _ b: [Float]) -> Float {
    var dotProduct: Float = 0
    var normA: Float = 0
    var normB: Float = 0
    for i in 0..<a.count {
        dotProduct += a[i] * b[i]
        normA += a[i] * a[i]
        normB += b[i] * b[i]
    }
    return dotProduct / (sqrt(normA) * sqrt(normB))
}

// SIMD最適化版
func cosineSimilaritySIMD(_ a: [Float], _ b: [Float]) -> Float {
    // Accelerate frameworkまたはsimd型を使用
    // 4-8倍の高速化が期待できる
}
```

**評価**: 効果的だが、既にSIMD最適化済みの場合は改善余地が少ない。

---

### パターンD: 階層的クラスタリング

**概要**: 全ペア比較を避け、階層的にクラスタリング

| 項目 | 内容 |
|------|------|
| 変更点 | アルゴリズムの根本的変更 |
| 期待改善 | 60-70% |
| 工数 | 80h（10日） |
| リスク | 大規模変更によるバグリスク |

```
階層的クラスタリングのフロー:

Level 1: 粗いグルーピング
[100,000枚] → ハッシュベースで1,000グループに分割

Level 2: グループ内詳細比較
[各グループ100枚] → 詳細類似度計算
計算量: 1,000グループ × 100^2 = 1000万回（50億回から500分の1）

Level 3: グループ間マージ
類似グループを統合
```

**評価**: 非常に効果的だが、実装工数が大きく、既存コードとの統合が複雑。

---

### パターンE: ハイブリッド最適化（推奨）

**概要**: パターンA-Dの要素を組み合わせた段階的アプローチ

| 項目 | 内容 |
|------|------|
| 変更点 | 4つの最適化を段階的に適用 |
| 期待改善 | **80-90%** |
| 工数 | 64h（8日） |
| リスク | 中程度（段階的導入で制御可能） |

```
ハイブリッドアプローチ:

Phase X1: 事前フィルタリング強化（16h）
├─ 日付ベース分割
├─ 時間窓の最適化
└─ 期待改善: 30%

Phase X2: LSH最適化（16h）
├─ パラメータチューニング
├─ マルチプローブLSH導入
└─ 期待改善: 追加20%

Phase X3: SIMD類似度計算（16h）
├─ Accelerate framework活用
├─ バッチ比較の実装
└─ 期待改善: 追加20%

Phase X4: メモリアクセス最適化（16h）
├─ データレイアウト最適化
├─ プリフェッチ戦略
└─ 期待改善: 追加10%

合計期待改善: 80-90%
```

---

## 4. 推奨: パターンE（ハイブリッド最適化）

### 4.1 選定理由

| 観点 | パターンE の優位性 |
|------|-------------------|
| **効果** | 80-90%改善で目標（数分）達成可能 |
| **リスク** | 段階的導入で各フェーズでの検証が可能 |
| **工数** | 64h（8日）で実現可能 |
| **既存コード** | 大規模リファクタリング不要 |
| **ロールバック** | 各フェーズで独立してロールバック可能 |

### 4.2 アーキテクチャ図

```
┌─────────────────────────────────────────────────────────────────┐
│                  Phase X ハイブリッド最適化                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [入力: 100,000枚の写真]                                         │
│         │                                                       │
│         ▼                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ X1: 事前フィルタリング                                    │   │
│  │ ├─ 日付ベース分割（例: 100日 × 1,000枚/日）              │   │
│  │ ├─ 各日付グループを独立処理（並列化可能）                  │   │
│  │ └─ 候補ペア数: 100,000^2 → 1,000^2 × 100 = 1億（50倍削減）│   │
│  └─────────────────────────────────────────────────────────┘   │
│         │                                                       │
│         ▼                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ X2: LSH最適化                                            │   │
│  │ ├─ マルチプローブLSH（候補再現率維持しつつ高速化）         │   │
│  │ ├─ 適応的バンド数（データ分布に応じて調整）               │   │
│  │ └─ 候補ペア数: 1億 → 500万（20倍削減）                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│         │                                                       │
│         ▼                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ X3: SIMD類似度計算                                        │   │
│  │ ├─ Accelerate frameworkによるベクトル演算               │   │
│  │ ├─ バッチ比較（複数ペアを同時計算）                       │   │
│  │ └─ 計算時間: 5分 → 1分（5倍高速化）                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│         │                                                       │
│         ▼                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ X4: メモリアクセス最適化                                   │   │
│  │ ├─ FeaturePrintのメモリレイアウト最適化                   │   │
│  │ ├─ 候補ペアのソート（キャッシュ効率向上）                  │   │
│  │ └─ 処理時間: 追加10%削減                                  │   │
│  └─────────────────────────────────────────────────────────┘   │
│         │                                                       │
│         ▼                                                       │
│  [出力: 類似グループ]                                            │
│  処理時間: 60分 → 3-6分（90%改善）                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 実装ロードマップ（Phase X1-X4）

### Phase X1: 事前フィルタリング強化（16h / 2日）

#### X1-1: 日付ベース分割（8h）

| 項目 | 内容 |
|------|------|
| 対象ファイル | PhotoGrouper.swift, TimeBasedGrouper.swift |
| 変更内容 | 日付別に写真を分割し、各グループを独立処理 |

```swift
// 擬似コード
func groupByDateThenAnalyze(_ assets: [PHAsset]) async throws -> [PhotoGroup] {
    // Step 1: 日付別に分割
    let dateGroups = Dictionary(grouping: assets) { asset in
        Calendar.current.startOfDay(for: asset.creationDate ?? Date())
    }

    // Step 2: 各日付グループを並列処理
    let results = try await withThrowingTaskGroup(of: [PhotoGroup].self) { group in
        for (_, assetsInDay) in dateGroups {
            group.addTask {
                return try await self.analyzeGroup(assetsInDay)
            }
        }

        var allGroups: [PhotoGroup] = []
        for try await dayGroups in group {
            allGroups.append(contentsOf: dayGroups)
        }
        return allGroups
    }

    return results
}
```

#### X1-2: 時間窓最適化（4h）

| 項目 | 内容 |
|------|------|
| 変更内容 | 時間窓をバースト撮影対応（10分）に短縮 |
| 期待効果 | 候補ペア数を50%削減 |

#### X1-3: テスト・検証（4h）

| テストID | 内容 | 合格基準 |
|----------|------|----------|
| X1-T01 | 日付分割の正確性 | 全写真が正しく分類 |
| X1-T02 | 並列処理の安定性 | クラッシュなし |
| X1-T03 | パフォーマンス | 30%改善 |

---

### Phase X2: LSH最適化（16h / 2日）

#### X2-1: マルチプローブLSH導入（8h）

| 項目 | 内容 |
|------|------|
| 対象ファイル | LSHHasher.swift |
| 変更内容 | 隣接バケットも探索するマルチプローブ方式 |

```swift
// 擬似コード
func multiProbeLSH(_ query: LSHHash, probeCount: Int = 3) -> Set<String> {
    var candidates: Set<String> = []

    // 元のバケット
    candidates.formUnion(hashTable[query.bucketKey] ?? [])

    // 隣接バケットを探索
    for probe in generateProbes(query, count: probeCount) {
        candidates.formUnion(hashTable[probe.bucketKey] ?? [])
    }

    return candidates
}
```

#### X2-2: 適応的バンド数（4h）

| 項目 | 内容 |
|------|------|
| 変更内容 | データサイズに応じてバンド数を動的調整 |
| ロジック | 写真数が多い → バンド数増加 → 候補削減 |

#### X2-3: テスト・検証（4h）

| テストID | 内容 | 合格基準 |
|----------|------|----------|
| X2-T01 | 候補ペア削減率 | 80%以上削減 |
| X2-T02 | False Negative率 | 5%未満 |
| X2-T03 | パフォーマンス | 追加20%改善 |

---

### Phase X3: SIMD類似度計算（16h / 2日）

#### X3-1: Accelerate framework統合（8h）

| 項目 | 内容 |
|------|------|
| 対象ファイル | SimilarityCalculator.swift |
| 変更内容 | vDSPを使用したベクトル演算 |

```swift
import Accelerate

func cosineSimilaritySIMD(_ a: [Float], _ b: [Float]) -> Float {
    var dotProduct: Float = 0
    var normA: Float = 0
    var normB: Float = 0

    // vDSPによる高速ベクトル演算
    vDSP_dotpr(a, 1, b, 1, &dotProduct, vDSP_Length(a.count))
    vDSP_dotpr(a, 1, a, 1, &normA, vDSP_Length(a.count))
    vDSP_dotpr(b, 1, b, 1, &normB, vDSP_Length(b.count))

    return dotProduct / (sqrt(normA) * sqrt(normB))
}
```

#### X3-2: バッチ比較実装（4h）

| 項目 | 内容 |
|------|------|
| 変更内容 | 複数ペアを同時に計算 |
| 期待効果 | CPU利用効率向上 |

#### X3-3: テスト・検証（4h）

| テストID | 内容 | 合格基準 |
|----------|------|----------|
| X3-T01 | 計算精度 | 誤差0.001未満 |
| X3-T02 | パフォーマンス | 4-8倍高速化 |
| X3-T03 | メモリ使用量 | 増加10%未満 |

---

### Phase X4: メモリアクセス最適化（16h / 2日）

#### X4-1: データレイアウト最適化（8h）

| 項目 | 内容 |
|------|------|
| 対象 | FeaturePrint配列のメモリ配置 |
| 変更内容 | 連続メモリ領域への配置、アライメント調整 |

```swift
// 擬似コード
struct OptimizedFeaturePrintStorage {
    // 全FeaturePrintを連続メモリに配置
    private var storage: ContiguousArray<Float>
    private let featureDimension: Int

    func getFeaturePrint(at index: Int) -> UnsafeBufferPointer<Float> {
        let start = index * featureDimension
        return UnsafeBufferPointer(
            start: storage.withUnsafeBufferPointer { $0.baseAddress! + start },
            count: featureDimension
        )
    }
}
```

#### X4-2: キャッシュ効率向上（4h）

| 項目 | 内容 |
|------|------|
| 変更内容 | 候補ペアをインデックス順にソートしてから処理 |
| 期待効果 | L3キャッシュヒット率向上 |

#### X4-3: テスト・検証（4h）

| テストID | 内容 | 合格基準 |
|----------|------|----------|
| X4-T01 | キャッシュヒット率 | 80%以上 |
| X4-T02 | 全体パフォーマンス | 追加10%改善 |
| X4-T03 | メモリ安定性 | リーク検出なし |

---

## 6. 期待効果と定量評価

### 6.1 フェーズ別期待改善

| Phase | 工数 | 期待改善率 | 累積改善率 | 処理時間（推定） |
|-------|------|-----------|-----------|-----------------|
| 現状 | - | - | 0% | 60分 |
| Phase 1完了 | 44h | 10% | 10% | 54分 |
| X1完了 | 16h | 30% | 37% | 38分 |
| X2完了 | 16h | 20% | 50% | 30分 |
| X3完了 | 16h | 20% | 60% | 24分 |
| X4完了 | 16h | 10% | 64% | 22分 |
| **理論上限** | - | - | **90%** | **6分** |

**注意**: 改善率は乗算で累積（0.9 × 0.8 × 0.8 × 0.9 = 0.52、つまり48%の時間に短縮）

### 6.2 1TB対応の見込み

| データ量 | 写真数（推定） | 現状処理時間 | Phase X後 |
|----------|---------------|-------------|-----------|
| 115GB | 100,000枚 | 60-80分 | 6-12分 |
| 500GB | 450,000枚 | 4-6時間 | 30-60分 |
| 1TB | 900,000枚 | 8-12時間 | 1-2時間 |

**注意**: 900,000枚でも実用的な時間内に完了可能。ただし、1TB対応には追加のメモリ管理最適化が必要な可能性あり。

### 6.3 投資対効果（ROI）

| 項目 | Phase 1のみ | Phase 1 + X |
|------|------------|-------------|
| 総工数 | 44h | 44h + 64h = 108h |
| 改善効果 | 10% | 90% |
| 工数あたり改善 | 0.23%/h | 0.83%/h |
| ユーザー体験 | 微改善 | 劇的改善 |

---

## 7. リスクと対策

| リスク | 確率 | 影響 | 対策 |
|--------|------|------|------|
| 日付分割による類似写真見逃し | 中 | 中 | 日をまたぐ場合のマージロジック追加 |
| SIMD最適化の効果不足 | 低 | 低 | 既存実装がSIMD対応済みか事前確認 |
| メモリ使用量増加 | 中 | 中 | メモリ監視、動的バッチサイズ調整 |
| 精度低下（False Negative増加） | 中 | 高 | パラメータ調整、A/Bテスト |

---

## 8. 成功基準

### 8.1 Phase X1-X4 完了基準

| Phase | 成功基準 |
|-------|----------|
| X1 | 処理時間30%以上削減、クラッシュなし |
| X2 | 候補ペア80%以上削減、False Negative5%未満 |
| X3 | 類似度計算4倍以上高速化 |
| X4 | 全体処理時間追加10%削減 |

### 8.2 最終目標

| 指標 | 目標値 |
|------|--------|
| 100,000枚処理時間 | **10分以内** |
| 1TB処理時間 | **2時間以内** |
| メモリピーク | 2GB未満 |
| False Negative率 | 5%未満 |

---

## 9. 次回セッションへの引き継ぎ

### 9.1 即座に開始可能なタスク

1. **X1-1: 日付ベース分割**（8h）
   - 対象: PhotoGrouper.swift
   - 既存コードへの影響: 小
   - 独立して実装・テスト可能

### 9.2 事前準備が必要なタスク

1. **X3-1: Accelerate framework統合**
   - 事前確認: 現在のSimilarityCalculatorがSIMD対応済みか確認
   - 必要知識: Accelerate framework API

2. **X4-1: データレイアウト最適化**
   - 事前確認: FeaturePrintの現在のメモリレイアウト調査
   - 必要知識: Swift unsafe pointer操作

### 9.3 推奨開始順序

```
Day 1-2: X1-1, X1-2（事前フィルタリング）
Day 3-4: X1-3, X2-1（テスト + LSH開始）
Day 5-6: X2-2, X2-3, X3-1（LSH完了 + SIMD開始）
Day 7-8: X3-2, X3-3, X4全体（SIMD完了 + メモリ最適化）
```

---

## 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|----------|
| 1.0 | 2026-01-06 | 初版作成（Phase 1効果検証後のPhase X計画） |

---

## 参照ドキュメント

- [パフォーマンス最適化計画](../PERFORMANCE_OPTIMIZATION_PLAN.md)
- [Phase 1 実装ガイド](../PHASE1_IMPLEMENTATION_GUIDE.md)
- [Phase 2 実装ガイド](../PHASE2_IMPLEMENTATION_GUIDE.md)
- [Phase 3 実装ガイド](../PHASE3_IMPLEMENTATION_GUIDE.md)
- [アーキテクチャ設計](./ARCHITECTURE.md)
